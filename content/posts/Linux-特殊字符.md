title: Linux_特殊字符
author: Esqer Yasen
tags:
  - Linux
  - 脚本
categories:
  - Linux
date: 2019-07-01 19:17:00
---
# Linux特殊字符
```

#注释
1、在shell文件的行首，作为include标记：#！/bin/bash。
2、在其他地方使用，作为注释，#后面的内容不会执行。
3、在单引号/双引号中间，或\#等表示#本身，不是注释。
      一个#表示从左边截取掉最短的匹配。
      两个#表示从左边截取掉最长的匹配。
     echo ${PATH#*:}     参数替换,不是一个注释。
     echo $((2#101011))  数制转换,不是一个注释。

;     分隔
1、命令分隔，在一行中写多个命令。 
      ls;date;pwd
2、在条件中的if和then如果放在同一行，也用;分隔。


;;     连续分号 
       case条件的结束。
 

.      点号

1、相当于source命令。
2、文件名的前缀，隐藏文件。
3、.当前目录，..父目录。
4、正则表达式：匹配任意单个字符。


""    双引号
1、部分引用，双引号包围内容，允许变量扩展，支持通配符扩展，也允许转义字符。
2、如果字符串内部出现双引号，需要转义。
    
 
'      单引号
1、全引用，禁止变量扩展，不进行通配符扩展，所有字符都作为字符本身。
2、单引号必须成对出现 。


\     反斜杠
1、放在特殊符号前，作为转义符。
2、放在一行指令最末端，表示紧接着的回车失效，后续新行依然是指令的一部分。

 

/     斜杠
1、目录分隔符，仅有一个斜杠表示根目录，以斜杠开头的路径表示从根目录开始的绝对路径。
2、除法运算符

 

,     逗号
1、用在一连串数学表达式中，所有表达式都被执行，但只有最后一个结果被返回。
2、用于参数替换中，表示首字母小写，如果两个逗号，则表示全部小写。
      str="GOOD"
      echo ${str,}  #输出gOOD
      echo ${str,,} #输出good
 
 
`    后引用
     命令替换，后引号包围内容作为命令执行，可将执行结果赋值给变量。

 
:     冒号
1、空命令，但有返回值(0:true)。
2、可做while死循环的条件。   while :
3、在if/then中表示什么都不做，引出分支
4、设置默认参数。   : ${username=`whoami`}
5、变量替换：    : ${HOSTNAME?} ${USER?} ${MAIL?}
6、在和 > (重定向操作符)结合使用时,把一个文件截断到0 长度,没有修改它的权限；如果文件在之前并不存在,那么就创建它.
      如:     
           : > data.xxx #文件"data.xxx"现在被清空了. 与 cat /dev/null >data.xxx 的作用相同 然而,这不会产生一个新的进程,因为":"是一个内建命令.
7、在和>>重定向操作符结合使用时,将不会对想要附加的文件产生任何影响.如果文件不存在,将创建.
8、作为域分隔符，比如环境变量$PATH，或者passwd文件中，都有冒号作为域分隔符的存在。
9、作为注释，#后面的内容不会被检查，但：后面的内容会被检查。


！  感叹号
1、表示一个反逻辑，比如！=表示不等于。
2、取反，比如ls ok[!a-z]  #表示ok后面不是紧接其他字符。
3、在不同的环境里，感叹号也可以出现在间接变量引用里面。
4、命令行中，可以用于历史命令机制的条件。


*     星号
1、作为通配符，匹配0个或多个字符。
2、数学乘法。


**   双星号
      幂运算
 
?    问号
1、条件测试。
2、通配符，匹配任意一个字符。
3、正则表达式中，表示通配前面的规则0次或者1次。
4、表示c语言中的三目运算(a>b?a:b)
 
 
$    美元符号
1、取变量的值 echo $PATH
2、正则表达式中表示行的结尾
${}     参数替换 ${PAHT} 
 $'...'  引用内容展开，执行单引号内的转义内容，这种方式会将引号内的一个或者多个[\]转义后的八进制，十六进制值展开到ASCII或UNICODE字符。  
$*     所有参数作为一个整体返回（字符串）
$@   将每个参数作为单元返回一个参数列表。
 $#  参数个数
 
 $$   运行当前脚本的进程ID。
$?    返回最后一次执行命令、函数或脚本的结果状态。执行正确为0，有错则非0.

( )   圆括号
1、命令组，其中的命令在子Shell中运行   (a=3;echo $a) 其中的变量不可被父shell获取，但子shell可以使用父shell中变量。
2、数组初始化： array=(a,b,c)

{ }  花括号 
      代码块，即一个匿名函数，但其中定义的变量在后面依然可用。
{ } \;       用在find的-exec中 $find -name *.txt -exec cat {} \;

 

[ ]   中括号
1、测试 [-z $1]
2、数组元素 a[1]='test'
3、表示字符集的范围，在正则表达式中，方括号表示该位置可以匹配的字符集范围。


[[]]    表示测试 使用[[ ... ]]条件判断结构, 而不是[ ... ], 能够防止脚本中的许多逻辑错误. 比如, &&, ||, <, 和> 操作符能够正常存在于[[ ]]条件判断结构中, 但是如果出现在[ ]结构中的话, 会报错.


$[...]   表示整数扩展，在方括号里面执行整数表达式。
      x=1
      y=2
      echo $[$x+$y]

(( ))    表示整数扩展，和上面的$[]差不多，但上者返回表达式的值，而本符号不返回值。
   

>       重定向: ls -a > a.txt   #重定向ls -a的输出到a.txt，如果文件存在则覆盖
&>    重定向：ls -a &> a.txt  #重定向ls -a的标准输出(stdout)和标准错误(stderr)到文件a.txt
>&   重定向：ls -a >&2       #重定向ls -a的标准输出(stdout)到标准错误(stderr)中。
>> 
       重定向: ls -a >> a.txt  #重定向ls -a的输出(同>)追加到a.txt，如果文件不存在则创建。
<>     重定向: [1]<>a.txt      #打开a.txt，并且指定1位文件描述符，文件不存在则创建。
<<    重定向： 用来将后续的内容重定向到左侧命令的stdin中。
<<<  重定向： 和<<类似。
>|     强制重定向(即使设置了noclobber 选项--就是-C 选项).这将强制的覆盖一个现存文件.
|      管道:将管道前的命令产生的输出(stdout)作为管道后的命令的输入(stdin)。
      ls -a|grep ok


>,<     大/小于号：用于变量的 ASCII比较。
      if [[ "$veg1" < "$veg2" ]]


\<,\>     正则表达式中的单词边界.

      如:  bash$grep '\<the\>' textfile


&     命令后跟 &,则在后台运行

||     逻辑或，用在两个命令之间的时候，表示在前一个命令结束时，若返回值为 false，继续执行下一个命令
  
&&   逻辑与，用在两个命令之间的时候，表示在前一个命令结束时，若返回值为 true，继续执行下一个命令
  
-
1、参数选项
2、减号
3、重定向stdin和stdout：cd /source/directory && tar cf - . ) | (cd /dest/directory && tar xpvf -)
4、先前的工作目录 cd -
       注：使用-开头的文件名和变量名可能会出现一些问题

+   
1、一个命令或者过滤器的选项标记。
2、加法。
3、正则表达式中，表示的是其前的这个匹配规则匹配最少一次。
4、参数替换中，+前缀表示替代值。

=
1、赋值操作
2、在比较测试中作为比较符出现，这里要注意，如果在中括号中作为比较出现，需要有空格符在等号左右两侧。

%
1、算术运算中求模操作符，即除法运算后的余数
2、参数替换中，可以作为模式匹配
3、一个%表示从右边截取最短的匹配
4、两个%表示从右边截取最长的匹配

~  home目录，和$HOME一样的。
~+  当前工作目录，这个和内置变量$PWD一样。
~-    先前工作目录，这个和内部变量$OLDPWD一样。
=~ 
      正则表达式匹配，可用在[[]]测试中。
      var="this is so good"
      [[ "$var" =~ tf*good ]] && echo "ok" || echo "false"
 
^ 
1、正则表达式中表示行首
2、参数替换中，一个^表示第一个字母大写，两个^表示全部大写。
$IFS 
用来做一些输入命令的分隔符, 默认情况下是空格.还包括制表符、空行、或者这几种组合。
控制字符修改终端或文本显示的行为. . 控制字符以CONTROL + key这种方式进行组合(同时按下). 控制字符也可以使用8进制或16进制表示法来进行表示, 但是前边必须要加上转义符.
控制字符在脚本中不能正常使用.
Ctl-B    退格(非破坏性的), 就是退格但是不删掉前面的字符.
Ctl-C    终结一个前台作业.
Ctl-D   从一个shell中登出(与exit很相像).
"EOF"(文件结束). 这也能从stdin中终止输入.
            在console或者在xterm窗口中输入的时候, Ctl-D将删除光标下字符. 当没有字符时, Ctl-D将退出当前会话, 在一个xterm窗口中, 则会产生关闭此窗口的效果.
Ctl-G  "哔" (beep). 在一些老式的打字机终端上, 它会响一下铃.
Ctl-H  "退格"(破坏性的), 就是在退格之后, 还要删掉前边的字符.
Ctl-I     水平制表符.
Ctl-J     重起一行(换一行并到行首). 在脚本中, 也可以使用8进制表示法 -- '\012' 或者16进制表示法 -- '\x0a' 来表示.
Ctl-K    垂直制表符.
Ctl-L    清屏(清除终端的屏幕显示). 在终端中, 与clear命令的效果相同. 当发送到打印机上时, Ctl-L会让打印机将打印纸卷到最后.
Ctl-M   回车.
Ctl-Q    恢复(XON).在一个终端中恢复stdin.
Ctl-S    挂起(XOFF).            在一个终端中冻结stdin. (使用Ctl-Q可以恢复输入.)
Ctl-U    删除光标到行首的所有字符. 在某些设置下, 不管光标的所在位置Ctl-U都将删除整行输入.
Ctl-V    当输入字符时, Ctl-V允许插入控制字符. 
Ctl-V    主要用于文本编辑.
Ctl-W    当在控制台或一个xterm窗口敲入文本时, Ctl-W将会删除当前光标到左边最近一个空格间的全部字符. 在某些设置下, Ctl-W将会删除当前光标到左边第一个非字母或数字之间的全部字符。
```